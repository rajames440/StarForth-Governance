// Jenkinsfile.disposition - PRODUCTION
// Document Disposition Pipeline - Pure Groovy Business Logic
// All file operations, logic, and data processing in Groovy DSL
// External tools (git, gh) called as needed

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Dry run mode (no commits/pushes)'
        )
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '50'))
        timeout(time: 2, unit: 'HOURS')
        disableConcurrentBuilds()
        timestamps()
    }

    environment {
        GOVERNANCE_REPO = 'rajames440/StarForth-Governance'
        WORKSPACE_REPO = "${WORKSPACE}"
        TIMESTAMP = new Date().format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'')
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "üìã Checking out StarForth-Governance repository..."
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/master']],
                        userRemoteConfigs: [[
                            url: "https://github.com/${env.GOVERNANCE_REPO}.git",
                            credentialsId: 'github-credentials'
                        ]]
                    ])
                }
            }
        }

        stage('Scan & Classify') {
            steps {
                script {
                    echo "üîç Scanning in_basket and classifying documents..."

                    try {
                        // Create output directories
                        sh 'mkdir -p /tmp/disposition-metadata /tmp/disposition-hints'

                        // Find all documents (exclude DO_NOT_REMOVE_ME)
                        def docList = sh(
                            script: 'find "${WORKSPACE}/in_basket" -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort',
                            returnStdout: true
                        ).trim().split('\n').findAll { it.length() > 0 }

                        env.DOC_COUNT = docList.size().toString()
                        echo "‚úì Found ${env.DOC_COUNT} document(s) in in_basket"

                        if (docList.isEmpty()) {
                            echo "[WARN] No documents to process"
                            return
                        }

                        // Process each document
                        docList.each { String docPath ->
                            String docName = docPath.replaceAll('.*/([^/]+)$', '$1')
                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Processing: ${docName}"

                            try {
                                // Read document content
                                String docContent = readFile(docPath)
                                String docContentLower = docContent.toLowerCase()

                                // Determine format
                                String format = 'other'
                                if (docName.endsWith('.adoc') || docName.endsWith('.asciidoc')) {
                                    format = 'asciidoc'
                                } else if (docName.endsWith('.md') || docName.endsWith('.markdown')) {
                                    format = 'markdown'
                                } else if (docName.endsWith('.pdf')) {
                                    format = 'pdf'
                                }

                                // Extract document type from content (multiple patterns)
                                String docType = extractDocumentType(docContent, docContentLower, docName, format)
                                String docTitle = extractDocumentTitle(docContent, docName, format)
                                List<String> requiredSigners = extractSigners(docContent, docContentLower)

                                echo "  Type: ${docType}"
                                echo "  Title: ${docTitle}"
                                echo "  Signers: ${requiredSigners.join(', ')}"

                                // Create metadata file
                                Map metadata = [
                                    type: docType,
                                    title: docTitle,
                                    required_signers: requiredSigners,
                                    format: format,
                                    needs_conversion: format != 'asciidoc'
                                ]

                                String metadataJson = groovy.json.JsonOutput.prettyPrint(
                                    groovy.json.JsonOutput.toJson(metadata)
                                )
                                writeFile file: "/tmp/disposition-metadata/${docName}.json", text: metadataJson

                                // Extract quality & governance keywords
                                Map hints = extractKeywordHints(docContentLower)
                                String hintsJson = groovy.json.JsonOutput.prettyPrint(
                                    groovy.json.JsonOutput.toJson(hints)
                                )
                                writeFile file: "/tmp/disposition-hints/${docName}.hints", text: hintsJson

                                echo "  ‚úì Metadata and hints created"

                            } catch (Exception e) {
                                echo "  ‚ùå Failed to process: ${e.message}"
                            }
                        }

                    } catch (Exception e) {
                        echo "‚ùå CRITICAL ERROR in Scan & Classify: ${e.message}"
                        throw e
                    }
                }
            }
        }

        stage('Route to Pending') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìÇ Routing documents to Pending/[TYPE]/ directories..."

                    try {
                        // Create pending directory
                        sh 'mkdir -p "${WORKSPACE}/Pending"'

                        // Get list of metadata files
                        def metadataList = sh(
                            script: 'find /tmp/disposition-metadata -maxdepth 1 -name "*.json" | sort',
                            returnStdout: true
                        ).trim().split('\n').findAll { it.length() > 0 }

                        int routed = 0
                        int failed = 0

                        metadataList.each { String metadataPath ->
                            String docName = metadataPath.replaceAll('.*/([^/]+)\\.json$', '$1')
                            String docInBasketPath = "${env.WORKSPACE}/in_basket/${docName}"

                            echo "Processing: ${docName}"

                            try {
                                // Check if document exists
                                if (!fileExists(docInBasketPath)) {
                                    echo "  ‚ö†Ô∏è Document not found (may be already routed)"
                                    return
                                }

                                // Read and parse metadata
                                String metadataContent = readFile(metadataPath)
                                def metadata = new groovy.json.JsonSlurper().parseText(metadataContent)
                                String docType = metadata.get('type', 'UNKNOWN')

                                // Create pending type directory
                                sh "mkdir -p \"\${WORKSPACE}/Pending/${docType}\""

                                // Add signature block if needed
                                if (!['ART', 'MIN', 'REL', 'RMP'].contains(docType)) {
                                    String docContent = readFile(docInBasketPath)
                                    String sigBlock = buildSignatureBlock(metadata)
                                    String updatedContent = docContent + '\n' + sigBlock
                                    writeFile file: docInBasketPath, text: updatedContent
                                    echo "  ‚úì Signature block added"
                                }

                                // Move document to pending
                                String pendingPath = "${env.WORKSPACE}/Pending/${docType}/${docName}"
                                sh "mv -v \"${docInBasketPath}\" \"${pendingPath}\""
                                echo "  ‚úì Routed to Pending/${docType}/"
                                routed++

                                // Check hints file
                                String hintsPath = "/tmp/disposition-hints/${docName}.hints"
                                if (fileExists(hintsPath)) {
                                    String hintsContent = readFile(hintsPath)
                                    def hints = new groovy.json.JsonSlurper().parseText(hintsContent)

                                    if (hints.hold_if_found) {
                                        sh "mkdir -p \"\${WORKSPACE}/Hold/${docType}\""
                                        sh "mv -v \"${pendingPath}\" \"\${WORKSPACE}/Hold/${docType}/${docName}\""
                                        echo "  ‚ö†Ô∏è HOLD: Document moved to Hold/${docType}/"
                                    }
                                    if (hints.escalate) {
                                        echo "  üö® ESCALATE: PM escalation flagged"
                                    }
                                }

                            } catch (Exception e) {
                                echo "  ‚ùå Error: ${e.message}"
                                failed++
                            }
                        }

                        echo ""
                        echo "Routing Summary: ${routed} routed, ${failed} failed"

                    } catch (Exception e) {
                        echo "‚ùå CRITICAL ERROR in Route to Pending: ${e.message}"
                        throw e
                    }
                }
            }
        }

        stage('Create Feature Branch') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üåø Creating feature branch..."
                    sh '''
                        cd "${WORKSPACE_REPO}"
                        git config user.name "Disposition Pipeline"
                        git config user.email "disposition@starforth.governance"
                        BRANCH_NAME="doc/disposition-$(date +%s)"
                        git checkout -b "${BRANCH_NAME}"
                        echo "${BRANCH_NAME}" > /tmp/branch_name
                    '''
                    env.BRANCH_NAME = readFile('/tmp/branch_name').trim()
                    echo "‚úì Branch: ${env.BRANCH_NAME}"
                }
            }
        }

        stage('Commit & Push') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üíæ Committing and pushing changes..."

                    sh '''
                        cd "${WORKSPACE_REPO}"
                        git add Pending/ Hold/ Security/ || true

                        if ! git diff --cached --quiet; then
                            git commit -m "docs(disposition): Route ${DOC_COUNT} document(s) to Pending/

- Timestamp: ${TIMESTAMP}
- Branch: ${BRANCH_NAME}
- Documents classified and routed for signature collection

[Disposition Pipeline]"

                            git push -u origin "${BRANCH_NAME}"
                            echo "‚úì Changes pushed"
                        else
                            echo "‚ÑπÔ∏è No changes to commit"
                        fi
                    '''
                }
            }
        }

        stage('Notify Signers') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìß Notifying signers via GitHub..."

                    try {
                        // Get list of metadata files
                        def metadataList = sh(
                            script: 'find /tmp/disposition-metadata -maxdepth 1 -name "*.json" | sort',
                            returnStdout: true
                        ).trim().split('\n').findAll { it.length() > 0 }

                        metadataList.each { String metadataPath ->
                            String metadataContent = readFile(metadataPath)
                            def metadata = new groovy.json.JsonSlurper().parseText(metadataContent)
                            String docName = metadataPath.replaceAll('.*/([^/]+)\\.json$', '$1')
                            String docType = metadata.type
                            String docTitle = metadata.title
                            List signers = metadata.required_signers ?: []

                            if (signers.isEmpty()) return

                            echo "Creating GitHub issue for: ${docName}"

                            String issueBody = """Document pending signature collection.

**Document:** ${docName}
**Type:** ${docType}
**Title:** ${docTitle}

**Required Signers:** ${signers.join(', ')}

**Action Required:**
1. Review document in Pending/${docType}/${docName}
2. Sign with GPG: gpg --detach-sign --armor ${docName}
3. Create signature: ${docName}.[your-username].asc
4. Commit and push

**Timeline:**
- Day 1: Reminder
- Day 3: PM escalation

Created: ${env.TIMESTAMP}
Branch: ${env.BRANCH_NAME}"""

                            sh """
                                cd "${env.WORKSPACE_REPO}"
                                gh issue create \\
                                  --title "üìã Document Pending Signature: ${docName}" \\
                                  --body "${issueBody.replace('"', '\\"')}" \\
                                  --label "governance,signature-needed" \\
                                  --assignee ${signers.join(',')} 2>/dev/null || echo "‚ö†Ô∏è Issue creation failed"
                            """
                        }

                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Notification error (non-blocking): ${e.message}"
                    }
                }
            }
        }

        stage('Setup Escalation') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "‚è∞ Setting up escalation tracking..."

                    try {
                        // Create escalation directory
                        sh 'mkdir -p "${WORKSPACE}/Security/Escalations"'

                        // Get list of metadata files
                        def metadataList = sh(
                            script: 'find /tmp/disposition-metadata -maxdepth 1 -name "*.json" | sort',
                            returnStdout: true
                        ).trim().split('\n').findAll { it.length() > 0 }

                        metadataList.each { String metadataPath ->
                            String metadataContent = readFile(metadataPath)
                            def metadata = new groovy.json.JsonSlurper().parseText(metadataContent)
                            String docName = metadataPath.replaceAll('.*/([^/]+)\\.json$', '$1')
                            String docType = metadata.type
                            String docTitle = metadata.title
                            List signers = metadata.required_signers ?: []

                            // Calculate dates
                            Date now = new Date()
                            Date day1 = new Date(now.time + (1000 * 60 * 60 * 24))
                            Date day3 = new Date(now.time + (1000 * 60 * 60 * 24 * 3))

                            String escalationContent = """# Escalation Tracking: ${docName}
type: ${docType}
title: ${docTitle}
routed_at: ${env.TIMESTAMP}
day1_reminder: ${day1.format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'')}
day3_escalate_pm: ${day3.format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'')}
signers_required:
${signers.collect { "  - ${it}" }.join('\n')}
status: PENDING_SIGNATURES
"""

                            writeFile file: "${env.WORKSPACE}/Security/Escalations/${docName}.escalation", text: escalationContent
                        }

                        echo "‚úì Escalation tracking created"

                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Escalation setup error (non-blocking): ${e.message}"
                    }
                }
            }
        }

        stage('Update Security Log') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üîê Updating security log..."

                    try {
                        String secLogPath = "${env.WORKSPACE}/Security/SEC_LOG.adoc"

                        // Create directory if needed
                        sh 'mkdir -p "${WORKSPACE}/Security"'

                        String logEntry = """
== Disposition Event: ${env.TIMESTAMP}

[cols="1,3"]
|===
|Event|${env.DOC_COUNT} document(s) routed to Pending
|Branch|${env.BRANCH_NAME}
|Status|PENDING_SIGNATURES
|Action|Awaiting required signatures or PM override
|===
"""

                        // Check if file exists and append or create
                        if (fileExists(secLogPath)) {
                            String existing = readFile(secLogPath)
                            writeFile file: secLogPath, text: existing + logEntry
                        } else {
                            String header = "= Security Event Log\n\n"
                            writeFile file: secLogPath, text: header + logEntry
                        }

                        echo "‚úì Security log updated"

                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Security log error (non-blocking): ${e.message}"
                    }
                }
            }
        }

        stage('Summary') {
            steps {
                script {
                    echo ""
                    echo "üìä Disposition Pipeline Summary"
                    echo "===================================="
                    echo "Timestamp:     ${env.TIMESTAMP}"
                    echo "Documents:     ${env.DOC_COUNT}"
                    echo "Branch:        ${env.BRANCH_NAME ?: 'N/A'}"
                    echo "Mode:          ${params.DRY_RUN ? 'DRY RUN' : 'LIVE'}"
                    echo ""
                    echo "‚úì All documents classified and routed"
                    echo "‚úì Signers notified via GitHub issues"
                    echo "‚úì Escalation tracking created"
                    echo "‚úì Changes committed and pushed"
                    echo ""
                    echo "Next Steps:"
                    echo "  ‚Üí Signers review and sign documents in Pending/[TYPE]/"
                    echo "  ‚Üí Documents move to Hold/ if issues found"
                    echo "  ‚Üí PM escalation on Day 3 for unsigned docs"
                    echo "===================================="
                }
            }
        }
    }

    post {
        always {
            script {
                echo "‚úÖ Pipeline execution complete"
            }
        }

        success {
            script {
                if (env.DOC_COUNT != "0" && !params.DRY_RUN) {
                    mail(
                        subject: "‚úì Disposition Pipeline Success - ${env.DOC_COUNT} document(s)",
                        body: "Documents processed successfully. Branch: ${env.BRANCH_NAME}",
                        to: "rajames440@gmail.com",
                        mimeType: 'text/plain'
                    )
                }
            }
        }

        failure {
            script {
                mail(
                    subject: "‚ùå Disposition Pipeline FAILED",
                    body: "Check Jenkins logs: ${env.BUILD_URL}console",
                    to: "rajames440@gmail.com",
                    mimeType: 'text/plain'
                )
            }
        }
    }
}

// ============ HELPER FUNCTIONS ============

String extractDocumentType(String content, String contentLower, String docName, String format) {
    // Pattern 1: Document ID field
    if (content =~ /\*\*Document ID:\*\*\s*\[([A-Z]+)-([0-9]+-[0-9]+)\]/) {
        def match = content =~ /\*\*Document ID:\*\*\s*\[([A-Z]+)-/
        if (match) return match[0][1]
    }

    // Pattern 2: Classification checkbox
    if (content =~ /\[x\]\s*\*\*([A-Z]+)\*\*/) {
        def match = content =~ /\[x\]\s*\*\*([A-Z]+)\*\*/
        if (match) return match[0][1]
    }

    // Pattern 3: Keyword inference
    if (contentLower.contains('failure') && contentLower.contains('mode')) return 'FMEA'
    if (contentLower.contains('engineering') && contentLower.contains('change') && contentLower.contains('request')) return 'ECR'
    if (contentLower.contains('engineering') && contentLower.contains('change') && contentLower.contains('order')) return 'ECO'
    if (contentLower.contains('corrective') || contentLower.contains('preventive')) return 'CAPA'
    if (contentLower.contains('security') && contentLower.contains('review')) return 'SEC'

    // Fallback: filename pattern
    if (docName =~ /^([A-Z]+)-[0-9]+/) {
        def match = docName =~ /^([A-Z]+)-/
        if (match) return match[0][1]
    }

    return 'UNKNOWN'
}

String extractDocumentTitle(String content, String docName, String format) {
    // Try to get title from heading
    if (format == 'markdown' && content =~ /^#+\s+(.+)$/) {
        def match = content =~ /^#+\s+(.+)$/
        if (match) return match[0][1]
    }

    if (content =~ /^=\s+(.+)$/) {
        def match = content =~ /^=\s+(.+)$/
        if (match) return match[0][1]
    }

    // Fallback to filename
    return docName.replaceAll('\\.[^.]+$', '')
}

List<String> extractSigners(String content, String contentLower) {
    List<String> signers = []

    // Look for "Submitted by:" field
    if (content =~ /\*\*Submitted by:\*\*\s*\[([^\]]+)\]/) {
        def match = content =~ /\*\*Submitted by:\*\*\s*\[([^\]]+)\]/
        if (match) {
            signers.add(match[0][1])
        }
    }

    // Default signer if none found
    if (signers.isEmpty()) {
        signers.add('rajames440')
    }

    return signers
}

Map extractKeywordHints(String contentLower) {
    Map hints = [
        escalate: false,
        pm_required: false,
        hold_if_found: false,
        additional_signers: '',
        found_categories: ''
    ]

    // Quality testing
    if (contentLower =~ /validation|verified|testing|test case|acceptance criteria/) {
        hints.found_categories += 'quality_testing;'
    }

    // Governance/Compliance
    if (contentLower =~ /governance|compliance|audit|policy|approval/) {
        hints.pm_required = true
        hints.found_categories += 'governance_compliance;'
    }

    // Risk Assessment
    if (contentLower =~ /risk|mitigation|severity/) {
        hints.escalate = true
        hints.pm_required = true
        hints.found_categories += 'risk_assessment;'
    }

    // Notes/TODOs
    if (contentLower =~ /todo|fixme|caveat|limitation/) {
        hints.hold_if_found = true
        hints.found_categories += 'notes_documentation;'
    }

    // Escalation/Priority
    if (contentLower =~ /urgent|blocker|deadline|critical/) {
        hints.escalate = true
        hints.pm_required = true
        hints.found_categories += 'escalation_priority;'
    }

    return hints
}

String buildSignatureBlock(Map metadata) {
    List signers = metadata.required_signers ?: ['rajames440']
    String signerRows = signers.collect { "| ${it} | Pending |  |" }.join('\n')

    return """
== Signatures

|===
| Signer | Status | Date | Signature

${signerRows}
|==="""
}