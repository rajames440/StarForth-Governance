// Jenkinsfile.disposition
// Document Disposition Pipeline - Main Orchestrator
// Manages the complete lifecycle of documents from in_basket to signed vault

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Dry run mode (no commits/pushes)'
        )
        string(
            name: 'PROCESS_DOCUMENT',
            defaultValue: '',
            description: 'Process specific document (filename). Leave empty for all.'
        )
    }

    triggers {
        // Poll for changes to in_basket every 15 minutes
        pollSCM('H/15 * * * *')
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '50'))
        timeout(time: 2, unit: 'HOURS')
        disableConcurrentBuilds()
        timestamps()
    }

    environment {
        GOVERNANCE_REPO = 'rajames440/StarForth-Governance'
        WORKSPACE_REPO = "${WORKSPACE}/governance"
        IN_BASKET = "${WORKSPACE_REPO}/in_basket"
        PENDING = "${WORKSPACE_REPO}/Pending"
        SEC_LOG = "${WORKSPACE_REPO}/Security/SEC_LOG.adoc"
        SIGNATURES_FILE = "${WORKSPACE_REPO}/Security/Signatures.adoc"
        GIT_AUTHOR_NAME = "Disposition Pipeline"
        GIT_AUTHOR_EMAIL = "disposition@starforth.governance"
        TIMESTAMP = sh(script: 'date -u +%Y-%m-%dT%H:%M:%SZ', returnStdout: true).trim()
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "üìã Checking out StarForth-Governance repository..."
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/master']],
                        userRemoteConfigs: [[
                            url: "https://github.com/${GOVERNANCE_REPO}.git",
                            credentialsId: 'github-credentials'
                        ]]
                    ])
                }
            }
        }

        stage('Scan In_Basket') {
            steps {
                script {
                    echo "üîç Scanning in_basket for new documents..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Find all documents (not DO_NOT_REMOVE_ME)
                        DOC_COUNT=$(find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | wc -l)
                        echo "Found ${DOC_COUNT} document(s) in in_basket"

                        if [ ${DOC_COUNT} -gt 0 ]; then
                            echo ""
                            echo "Documents ready for processing:"
                            find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                                echo "  - $(basename "$doc")"
                            done
                        fi

                        echo "${DOC_COUNT}" > /tmp/doc_count
                    '''

                    env.DOC_COUNT = readFile('/tmp/doc_count').trim()
                }
            }
        }

        stage('Process Documents') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üì¶ Processing ${DOC_COUNT} document(s)..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Process each document
                        find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                            doc_name=$(basename "$doc")
                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Processing: ${doc_name}"

                            # For now, just log that we found the document
                            # Full processing logic to be implemented in next stage
                            echo "  Status: Queued for disposition"
                        done
                    '''
                }
            }
        }

        stage('Classify & Extract Metadata') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üî¨ Using Claude to classify documents and extract metadata..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Create temporary metadata directory
                        mkdir -p /tmp/disposition-metadata

                        # Read each document and use Claude to classify
                        find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                            doc_name=$(basename "$doc")
                            doc_path="${IN_BASKET}/${doc_name}"

                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Analyzing: ${doc_name}"

                            # Use Claude to analyze document
                            # Returns JSON with: type, required_signers, title, format
                            echo "  ‚Üí Scanning document content with Claude..."

                            DOC_CONTENT=$(cat "${doc_path}")
                            claude --print --output-format json "Analyze this governance document and respond ONLY with valid JSON containing type, title, required_signers, format, and needs_conversion:

\${DOC_CONTENT}

{\"type\": \"CAPA|ECR|ECO|FMEA|DHR|DMR|CER|DWG|ENG|SEC|IR|VAL|DTA|ART|MIN|REL|RMP|UNKNOWN\", \"title\": \"title\", \"required_signers\": [\"list\"], \"format\": \"asciidoc|markdown|pdf|docx|other\", \"needs_conversion\": true or false}" > "/tmp/disposition-metadata/${doc_name}.json" 2>&1 || {
                                echo "  ‚ö†Ô∏è Claude analysis failed, using fallback classification"
                                # Fallback: basic filename-based classification
                                echo "{\"type\": \"UNKNOWN\", \"error\": \"claude_analysis_failed\"}" > "/tmp/disposition-metadata/${doc_name}.json"
                            }

                            # Display results
                            if [ -f "/tmp/disposition-metadata/${doc_name}.json" ]; then
                                DOC_TYPE=$(jq -r '.type // "UNKNOWN"' "/tmp/disposition-metadata/${doc_name}.json")
                                DOC_TITLE=$(jq -r '.title // ""' "/tmp/disposition-metadata/${doc_name}.json")
                                SIGNERS=$(jq -r '.required_signers // []' "/tmp/disposition-metadata/${doc_name}.json")

                                echo "  Type: ${DOC_TYPE}"
                                echo "  Title: ${DOC_TITLE}"
                                echo "  Signers Required: ${SIGNERS}"
                            fi
                        done
                    '''
                }
            }
        }

        stage('Verify Git Status') {
            steps {
                script {
                    echo "‚úì Verifying git status..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Check git config
                        echo "Git configuration:"
                        git config user.name || echo "  user.name not set"
                        git config user.email || echo "  user.email not set"

                        # Show current branch
                        echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"

                        # Show status
                        echo "Status:"
                        git status --short | head -20
                    '''
                }
            }
        }

        stage('Convert Formats & Add Signatures') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üîÑ Converting formats to AsciiDoc and adding signature blocks..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Process each document metadata
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)
                            doc_path="${IN_BASKET}/${doc_name}"
                            metadata=$(cat "${metadata_file}")

                            echo "Processing metadata for: ${doc_name}"

                            # Check if format conversion needed
                            NEEDS_CONVERSION=$(echo "${metadata}" | jq -r '.needs_conversion // false')
                            FORMAT=$(echo "${metadata}" | jq -r '.format // "unknown"')
                            DOC_TYPE=$(echo "${metadata}" | jq -r '.type // "UNKNOWN"')

                            if [ "${NEEDS_CONVERSION}" = "true" ] && [ "${FORMAT}" != "asciidoc" ]; then
                                echo "  ‚Üí Converting from ${FORMAT} to AsciiDoc..."

                                # Use Claude to convert document format
                                DOC_CONTENT=$(cat "${doc_path}")
                                claude --print "Convert this ${FORMAT} document to AsciiDoc format. Preserve all content, structure, and meaning. Output ONLY the AsciiDoc content, no explanations.

\${DOC_CONTENT}" \
                                    > "${doc_path}.asciidoc" 2>&1 || {
                                    echo "  ‚ö†Ô∏è Conversion failed for ${doc_name}"
                                    continue
                                }

                                # Replace original with converted version
                                mv "${doc_path}.asciidoc" "${doc_path}"
                                echo "  ‚úì Converted to AsciiDoc"
                            fi

                            # Add signature block if controlled document (use bash, not Claude)
                            if [[ ! "${DOC_TYPE}" =~ ^(ART|MIN|REL|RMP)$ ]]; then
                                echo "  ‚Üí Adding signature block..."

                                # Build signature rows from metadata
                                SIGNERS=$(echo "${metadata}" | jq -r '.required_signers[]')
                                SIGNER_ROWS=""
                                while IFS= read -r signer; do
                                    SIGNER_ROWS="${SIGNER_ROWS}| ${signer} | Pending |  |
"
                                done <<< "${SIGNERS}"

                                # Append signature block to document (simple bash append, no Claude)
                                cat >> "${doc_path}" << SIGBLOCK

== Signatures

|===
| Signer | Status | Date | Signature

${SIGNER_ROWS}|===
SIGBLOCK

                                if [ $? -eq 0 ]; then
                                    echo "  ‚úì Signature block added"
                                else
                                    echo "  ‚ö†Ô∏è Signature block addition failed"
                                fi
                            fi
                        done
                    '''
                }
            }
        }

        stage('Route to Pending') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìÇ Routing processed documents to Pending/[TYPE]/ directories..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Create Pending directory if it doesn't exist
                        mkdir -p Pending

                        # Process each document from metadata
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)
                            doc_path="${IN_BASKET}/${doc_name}"

                            if [ ! -f "${doc_path}" ]; then
                                echo "‚ö†Ô∏è Document not found: ${doc_name}"
                                continue
                            fi

                            # Extract document type from metadata
                            DOC_TYPE=$(jq -r '.type // "UNKNOWN"' "${metadata_file}")
                            DOC_TITLE=$(jq -r '.title // ""' "${metadata_file}")

                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Routing: ${doc_name}"
                            echo "  Type: ${DOC_TYPE}"
                            echo "  Title: ${DOC_TITLE}"

                            # Create type-specific pending directory
                            PENDING_TYPE_DIR="Pending/${DOC_TYPE}"
                            mkdir -p "${PENDING_TYPE_DIR}"

                            # Copy document to Pending directory
                            cp "${doc_path}" "${PENDING_TYPE_DIR}/${doc_name}"

                            if [ $? -eq 0 ]; then
                                # Save document type and title for later use
                                echo "${DOC_TYPE}" > "/tmp/doc-${doc_name}.type"
                                echo "${DOC_TITLE}" > "/tmp/doc-${doc_name}.title"
                                echo "  ‚úì Routed to Pending/${DOC_TYPE}/"
                            else
                                echo "  ‚ö†Ô∏è Failed to route document"
                            fi
                        done
                    '''
                }
            }
        }

        stage('Create Feature Branch') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üåø Creating feature branch for document processing..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Create a single branch for this disposition batch
                        BRANCH_NAME="doc/disposition-$(date +%s)"

                        git checkout -b "${BRANCH_NAME}"
                        echo "Created branch: ${BRANCH_NAME}"
                        echo "${BRANCH_NAME}" > /tmp/branch_name
                    '''

                    env.BRANCH_NAME = readFile('/tmp/branch_name').trim()
                }
            }
        }

        stage('Create Routing PR (PR #1)') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìã Creating internal PR #1: Document routing to Pending/..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Set git configuration for commits
                        git config user.name "${GIT_AUTHOR_NAME}"
                        git config user.email "${GIT_AUTHOR_EMAIL}"

                        # Stage all Pending directory changes
                        git add Pending/

                        # Check if there are changes to commit
                        if git diff --cached --quiet; then
                            echo "‚ÑπÔ∏è No changes to commit (DRY_RUN or no documents routed)"
                        else
                            # Create commit with timestamp
                            git commit -m "docs(disposition): Route ${DOC_COUNT} document(s) to Pending/

- Processing timestamp: ${TIMESTAMP}
- Documents ready for signature collection
- PR #1 of 4: Initial routing to workflow

[Disposition Pipeline]"

                            echo "‚úì PR #1 commit created: $(git rev-parse --short HEAD)"
                            git log --oneline -1
                        fi
                    '''
                }
            }
        }

        stage('Notify Signers') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìß Notifying required signers via GitHub..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Process each document to identify signers
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)

                            # Extract signers from metadata
                            SIGNERS=$(jq -r '.required_signers[]?' "${metadata_file}")
                            DOC_TITLE=$(jq -r '.title // ""' "${metadata_file}")
                            DOC_TYPE=$(jq -r '.type // "UNKNOWN"' "${metadata_file}")

                            if [ -z "${SIGNERS}" ]; then
                                echo "‚ÑπÔ∏è No signers required for: ${doc_name}"
                                continue
                            fi

                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "üì¢ Notifying signers for: ${doc_name}"
                            echo "   Title: ${DOC_TITLE}"
                            echo "   Type: ${DOC_TYPE}"
                            echo "   Signers:"

                            # Build list of signers with @ mentions
                            SIGNER_MENTIONS=""
                            echo "${SIGNERS}" | while read signer; do
                                echo "     - ${signer}"
                                SIGNER_MENTIONS="${SIGNER_MENTIONS}@${signer} "
                            done

                            # Create GitHub issue notification
                            if command -v gh &> /dev/null; then
                                echo "  ‚Üí Creating GitHub issue notification..."

                                # Create issue with signer mentions
                                ISSUE_BODY="Document pending signature collection.

**Document:** \`${doc_name}\`
**Type:** ${DOC_TYPE}
**Title:** ${DOC_TITLE}

**Required Signers:**
$(echo "${SIGNERS}" | sed 's/^/- @/' | paste -sd '' -)

**Action Required:**
1. Review document in \`Pending/${DOC_TYPE}/${doc_name}\`
2. Sign with GPG: \`gpg --detach-sign --armor ${doc_name}\`
3. Create detached signature: \`${doc_name}.[your-username].asc\`
4. Commit to repository or notify pipeline

**Timeline:**
- Day 1: Reminder notification
- Day 3: PM escalation if not signed

Created: ${TIMESTAMP}
Branch: ${BRANCH_NAME}"

                                gh issue create \
                                  --title "üìã Document Pending Signature: ${doc_name}" \
                                  --body "${ISSUE_BODY}" \
                                  --label "governance,signature-needed" \
                                  --assignee ${SIGNERS} 2>&1 || {
                                    echo "  ‚ö†Ô∏è GitHub issue creation may have failed (check below)"
                                }

                                echo "  ‚úì GitHub issue created and signers assigned"
                            else
                                echo "  ‚ö†Ô∏è gh CLI not available, falling back to notification log"
                                echo "[NOTIFY] GitHub Issue: ${doc_name}" >> /tmp/notification-log
                                echo "${SIGNERS}" | while read signer; do
                                    echo "[NOTIFY] @${signer}: Please sign ${doc_name}" >> /tmp/notification-log
                                done
                            fi
                        done

                        # Summary
                        if [ -f /tmp/notification-log ]; then
                            echo ""
                            echo "Notification Summary:"
                            cat /tmp/notification-log
                        fi
                    '''
                }
            }
        }

        stage('Setup Escalation Tracking') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "‚è∞ Setting up escalation tracking for pending documents..."

                    sh '''
                        # Create escalation tracking directory
                        mkdir -p "${WORKSPACE_REPO}/Security/Escalations"

                        # Process each document
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)
                            DOC_TITLE=$(jq -r '.title // ""' "${metadata_file}")
                            DOC_TYPE=$(jq -r '.type // ""' "${metadata_file}")
                            SIGNERS=$(jq -r '.required_signers[]?' "${metadata_file}")

                            echo "Setting up escalation for: ${doc_name}"

                            # Create escalation tracking file
                            ESCALATION_FILE="${WORKSPACE_REPO}/Security/Escalations/${doc_name}.escalation"
                            cat > "${ESCALATION_FILE}" << ESCALATION
# Escalation Tracking: ${doc_name}
title: ${DOC_TITLE}
type: ${DOC_TYPE}
routed_at: ${TIMESTAMP}
day1_reminder: $(date -u -d '+1 day' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v+1d +%Y-%m-%dT%H:%M:%SZ)
day3_escalate_pm: $(date -u -d '+3 days' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v+3d +%Y-%m-%dT%H:%M:%SZ)
signers_required:
${SIGNERS:+$(echo "${SIGNERS}" | sed 's/^/  - /')}
status: PENDING_SIGNATURES
ESCALATION

                            if [ -f "${ESCALATION_FILE}" ]; then
                                echo "  ‚úì Escalation tracking created"
                            fi
                        done

                        # List all tracked escalations
                        echo ""
                        echo "Active Escalations:"
                        ls -la "${WORKSPACE_REPO}/Security/Escalations/" 2>/dev/null | tail -n +4 || echo "  (none)"
                    '''
                }
            }
        }

        stage('Update Security Log') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üîê Updating Security Event Log..."

                    sh '''
                        SEC_LOG="${WORKSPACE_REPO}/Security/SEC_LOG.adoc"

                        if [ ! -f "${SEC_LOG}" ]; then
                            echo "‚ö†Ô∏è Security log not found at ${SEC_LOG}"
                            exit 0
                        fi

                        # Append disposition events to security log
                        cat >> "${SEC_LOG}" << LOG_ENTRY

== Disposition Event: ${TIMESTAMP}

[cols="1,3"]
|===
|Event|${DOC_COUNT} document(s) routed to Pending
|Branch|${BRANCH_NAME}
|Status|PENDING_SIGNATURES
|Action|Awaiting required signatures or PM override
|===

LOG_ENTRY

                        echo "‚úì Security log updated"
                    '''
                }
            }
        }

        stage('Commit Workflow Changes') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üíæ Committing workflow state changes..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        git config user.name "${GIT_AUTHOR_NAME}"
                        git config user.email "${GIT_AUTHOR_EMAIL}"

                        # Stage escalation and log changes
                        git add Security/Escalations/ || true
                        git add Security/SEC_LOG.adoc || true

                        if ! git diff --cached --quiet; then
                            git commit -m "docs(disposition): Update escalation tracking and security log

- Setup Day 1 reminder and Day 3 PM escalation tracking
- Record disposition event in Security Event Log
- Timestamp: ${TIMESTAMP}
- Branch: ${BRANCH_NAME}

[Disposition Pipeline - Escalation Setup]"

                            echo "‚úì Workflow changes committed"
                        else
                            echo "‚ÑπÔ∏è No workflow changes to commit"
                        fi
                    '''
                }
            }
        }

        stage('Push to GitHub') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üöÄ Pushing disposition changes to GitHub..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Check if there are commits to push
                        COMMITS=$(git rev-list origin/master..HEAD 2>/dev/null | wc -l)

                        if [ "${COMMITS}" -eq 0 ]; then
                            echo "‚ÑπÔ∏è No commits to push"
                            exit 0
                        fi

                        echo "Commits to push: ${COMMITS}"
                        echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"

                        # Push feature branch to GitHub
                        git push -u origin "${BRANCH_NAME}" 2>&1

                        if [ $? -eq 0 ]; then
                            echo "‚úì Branch pushed: ${BRANCH_NAME}"
                        else
                            echo "‚ö†Ô∏è Failed to push branch"
                            exit 1
                        fi

                        # Show commits to be merged to master
                        echo ""
                        echo "Commits ready for master:"
                        git log --oneline origin/master..HEAD | head -10
                    '''
                }
            }
        }

        stage('Summary') {
            steps {
                script {
                    echo ""
                    echo "üìä Disposition Pipeline Summary"
                    echo "===================================="
                    echo "Execution:     ${TIMESTAMP}"
                    echo "Documents:     ${DOC_COUNT}"
                    if (env.BRANCH_NAME) {
                        echo "Branch:        ${BRANCH_NAME}"
                    }
                    echo ""
                    echo "Pipeline Stages:"
                    echo "  ‚úì Scanned in_basket"
                    echo "  ‚úì Classified documents"
                    echo "  ‚úì Converted formats & added signatures"
                    echo "  ‚úì Routed to Pending/[TYPE]/"
                    echo "  ‚úì Created PR #1 (routing)"
                    echo "  ‚úì Notified signers"
                    echo "  ‚úì Setup escalation tracking"
                    echo "  ‚úì Updated security log"
                    echo ""
                    if (params.DRY_RUN) {
                        echo "Mode:          DRY RUN (no commits/pushes)"
                    } else {
                        echo "Mode:          LIVE (changes committed & pushed)"
                    }
                    echo ""
                    echo "Next Steps:"
                    echo "  ‚Üí Signers verify and sign documents in Pending/[TYPE]/"
                    echo "  ‚Üí Day 1: Reminder notification sent"
                    echo "  ‚Üí Day 3: PM escalation for unsigned documents"
                    echo "  ‚Üí Upon completion: Create PR #4 (move to vault)"
                    echo "===================================="
                }
            }
        }
    }

    post {
        always {
            script {
                echo "‚úÖ Pipeline execution complete"
                echo "Build Status: ${currentBuild.result}"
            }
        }

        success {
            script {
                echo "‚úì Documents processed successfully"
            }
        }

        failure {
            script {
                echo "‚ùå Pipeline encountered errors"
            }
        }
    }
}
