// Jenkinsfile.disposition
// Document Disposition Pipeline - Main Orchestrator
// Manages the complete lifecycle of documents from in_basket to signed vault

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Dry run mode (no commits/pushes)'
        )
        string(
            name: 'PROCESS_DOCUMENT',
            defaultValue: '',
            description: 'Process specific document (filename). Leave empty for all.'
        )
    }

    triggers {
        // Poll for changes to in_basket every 15 minutes
        pollSCM('H/15 * * * *')
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '50'))
        timeout(time: 2, unit: 'HOURS')
        disableConcurrentBuilds()
        timestamps()
    }

    environment {
        GOVERNANCE_REPO = 'rajames440/StarForth-Governance'
        WORKSPACE_REPO = "${WORKSPACE}/governance"
        IN_BASKET = "${WORKSPACE_REPO}/in_basket"
        PENDING = "${WORKSPACE_REPO}/Pending"
        SEC_LOG = "${WORKSPACE_REPO}/Security/SEC_LOG.adoc"
        SIGNATURES_FILE = "${WORKSPACE_REPO}/Security/Signatures.adoc"
        GIT_AUTHOR_NAME = "Disposition Pipeline"
        GIT_AUTHOR_EMAIL = "disposition@starforth.governance"
        TIMESTAMP = sh(script: 'date -u +%Y-%m-%dT%H:%M:%SZ', returnStdout: true).trim()
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "üìã Checking out StarForth-Governance repository..."
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/master']],
                        userRemoteConfigs: [[
                            url: "https://github.com/${GOVERNANCE_REPO}.git",
                            credentialsId: 'github-credentials'
                        ]]
                    ])
                }
            }
        }

        stage('Scan In_Basket') {
            steps {
                script {
                    echo "üîç Scanning in_basket for new documents..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Find all documents (not DO_NOT_REMOVE_ME)
                        DOC_COUNT=$(find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | wc -l)
                        echo "Found ${DOC_COUNT} document(s) in in_basket"

                        if [ ${DOC_COUNT} -gt 0 ]; then
                            echo ""
                            echo "Documents ready for processing:"
                            find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                                echo "  - $(basename "$doc")"
                            done
                        fi

                        echo "${DOC_COUNT}" > /tmp/doc_count
                    '''

                    env.DOC_COUNT = readFile('/tmp/doc_count').trim()
                }
            }
        }

        stage('Process Documents') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üì¶ Processing ${DOC_COUNT} document(s)..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Process each document
                        find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                            doc_name=$(basename "$doc")
                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Processing: ${doc_name}"

                            # For now, just log that we found the document
                            # Full processing logic to be implemented in next stage
                            echo "  Status: Queued for disposition"
                        done
                    '''
                }
            }
        }

        stage('Classify & Extract Metadata') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üî¨ Using Claude to classify documents and extract metadata..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Create temporary metadata directory
                        mkdir -p /tmp/disposition-metadata

                        # Read each document and use Claude to classify
                        find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                            doc_name=$(basename "$doc")
                            doc_path="${IN_BASKET}/${doc_name}"

                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Analyzing: ${doc_name}"

                            # Use Claude to analyze document
                            # Returns JSON with: type, required_signers, title, format
                            echo "  ‚Üí Scanning document content with Claude..."

                            claude --file "${doc_path}" \
                                "Read this governance document and respond with JSON containing:
                                {
                                  \"type\": \"CAPA|ECR|ECO|FMEA|DHR|DMR|CER|DWG|ENG|SEC|IR|VAL|DTA|ART|MIN|REL|RMP|UNKNOWN\",
                                  \"title\": \"Document title\",
                                  \"required_signers\": [\"signer1\", \"signer2\"],
                                  \"format\": \"asciidoc|markdown|pdf|docx|other\",
                                  \"needs_conversion\": true|false
                                }" > "/tmp/disposition-metadata/${doc_name}.json" 2>&1 || {
                                echo "  ‚ö†Ô∏è Claude analysis failed, using fallback classification"
                                # Fallback: basic filename-based classification
                                echo "{\"type\": \"UNKNOWN\", \"error\": \"claude_analysis_failed\"}" > "/tmp/disposition-metadata/${doc_name}.json"
                            }

                            # Display results
                            if [ -f "/tmp/disposition-metadata/${doc_name}.json" ]; then
                                DOC_TYPE=$(jq -r '.type // "UNKNOWN"' "/tmp/disposition-metadata/${doc_name}.json")
                                DOC_TITLE=$(jq -r '.title // ""' "/tmp/disposition-metadata/${doc_name}.json")
                                SIGNERS=$(jq -r '.required_signers // []' "/tmp/disposition-metadata/${doc_name}.json")

                                echo "  Type: ${DOC_TYPE}"
                                echo "  Title: ${DOC_TITLE}"
                                echo "  Signers Required: ${SIGNERS}"
                            fi
                        done
                    '''
                }
            }
        }

        stage('Verify Git Status') {
            steps {
                script {
                    echo "‚úì Verifying git status..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Check git config
                        echo "Git configuration:"
                        git config user.name || echo "  user.name not set"
                        git config user.email || echo "  user.email not set"

                        # Show current branch
                        echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"

                        # Show status
                        echo "Status:"
                        git status --short | head -20
                    '''
                }
            }
        }

        stage('Convert Formats & Add Signatures') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üîÑ Converting formats to AsciiDoc and adding signature blocks..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Process each document metadata
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)
                            doc_path="${IN_BASKET}/${doc_name}"
                            metadata=$(cat "${metadata_file}")

                            echo "Processing metadata for: ${doc_name}"

                            # Check if format conversion needed
                            NEEDS_CONVERSION=$(echo "${metadata}" | jq -r '.needs_conversion // false')
                            FORMAT=$(echo "${metadata}" | jq -r '.format // "unknown"')
                            DOC_TYPE=$(echo "${metadata}" | jq -r '.type // "UNKNOWN"')

                            if [ "${NEEDS_CONVERSION}" = "true" ] && [ "${FORMAT}" != "asciidoc" ]; then
                                echo "  ‚Üí Converting from ${FORMAT} to AsciiDoc..."

                                # Use Claude to convert document format
                                claude --file "${doc_path}" \
                                    "Convert this ${FORMAT} document to AsciiDoc format. Preserve all content, structure, and meaning. Output ONLY the AsciiDoc content, no explanations." \
                                    > "${doc_path}.asciidoc" 2>&1 || {
                                    echo "  ‚ö†Ô∏è Conversion failed for ${doc_name}"
                                    continue
                                }

                                # Replace original with converted version
                                mv "${doc_path}.asciidoc" "${doc_path}"
                                echo "  ‚úì Converted to AsciiDoc"
                            fi

                            # Add signature block if controlled document
                            if [[ ! "${DOC_TYPE}" =~ ^(ART|MIN|REL|RMP)$ ]]; then
                                echo "  ‚Üí Adding signature block..."

                                # Use Claude to append signature block to document
                                claude --file "${doc_path}" \
                                    "Append this signature block to the end of the document (after all content):

== Signatures

|===
| Signer | Status | Date | Signature

$(echo "${metadata}" | jq -r '.required_signers[]' | while read signer; do
    echo "| ${signer} | Pending |  |"
done)
|===

Output the complete document with the signature block appended." \
                                    > "${doc_path}.with-sig" 2>&1 || {
                                    echo "  ‚ö†Ô∏è Signature block addition failed"
                                    continue
                                }

                                # Replace original with signed version
                                mv "${doc_path}.with-sig" "${doc_path}"
                                echo "  ‚úì Signature block added"
                            fi
                        done
                    '''
                }
            }
        }

        stage('Create Feature Branch') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üåø Creating feature branch for document processing..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # For initial implementation, create a single branch
                        # In full implementation, create one per document
                        BRANCH_NAME="doc/disposition-$(date +%s)"

                        git checkout -b "${BRANCH_NAME}"
                        echo "Created branch: ${BRANCH_NAME}"
                        echo "${BRANCH_NAME}" > /tmp/branch_name
                    '''

                    env.BRANCH_NAME = readFile('/tmp/branch_name').trim()
                }
            }
        }

        stage('Summary') {
            steps {
                script {
                    echo "üìä Disposition Pipeline Summary"
                    echo "=================================="
                    echo "Execution: ${TIMESTAMP}"
                    echo "Documents found: ${DOC_COUNT}"
                    if (env.BRANCH_NAME) {
                        echo "Branch: ${BRANCH_NAME}"
                    }
                    if (params.DRY_RUN) {
                        echo "Mode: DRY RUN (no commits)"
                    } else {
                        echo "Mode: LIVE (will commit changes)"
                    }
                    echo "Status: READY FOR NEXT STAGES"
                    echo "=================================="
                }
            }
        }
    }

    post {
        always {
            script {
                echo "‚úÖ Pipeline execution complete"
                echo "Build Status: ${currentBuild.result}"
            }
        }

        success {
            script {
                echo "‚úì Documents processed successfully"
            }
        }

        failure {
            script {
                echo "‚ùå Pipeline encountered errors"
            }
        }
    }
}
