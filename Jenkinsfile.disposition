// Jenkinsfile.disposition
// Document Disposition Pipeline - Main Orchestrator
// Manages the complete lifecycle of documents from in_basket to signed vault

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Dry run mode (no commits/pushes)'
        )
        string(
            name: 'PROCESS_DOCUMENT',
            defaultValue: '',
            description: 'Process specific document (filename). Leave empty for all.'
        )
    }

    triggers {
        // Poll for changes to in_basket every 15 minutes
        pollSCM('H/15 * * * *')
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '50'))
        timeout(time: 2, unit: 'HOURS')
        disableConcurrentBuilds()
        timestamps()
    }

    environment {
        GOVERNANCE_REPO = 'rajames440/StarForth-Governance'
        WORKSPACE_REPO = "${WORKSPACE}"
        IN_BASKET = "${WORKSPACE_REPO}/in_basket"
        PENDING = "${WORKSPACE_REPO}/Pending"
        SEC_LOG = "${WORKSPACE_REPO}/Security/SEC_LOG.adoc"
        SIGNATURES_FILE = "${WORKSPACE_REPO}/Security/Signatures.adoc"
        GIT_AUTHOR_NAME = "Disposition Pipeline"
        GIT_AUTHOR_EMAIL = "disposition@starforth.governance"
        TIMESTAMP = sh(script: 'date -u +%Y-%m-%dT%H:%M:%SZ', returnStdout: true).trim()
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "üìã Checking out StarForth-Governance repository..."
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/master']],
                        userRemoteConfigs: [[
                            url: "https://github.com/${GOVERNANCE_REPO}.git",
                            credentialsId: 'github-credentials'
                        ]]
                    ])
                }
            }
        }

        stage('Scan In_Basket') {
            steps {
                script {
                    echo "üîç Scanning in_basket for new documents..."

                    sh '''
                        echo "========== SCAN IN_BASKET STAGE =========="
                        echo "[DEBUG] Current working directory: $(pwd)"
                        echo "[DEBUG] IN_BASKET variable: ${IN_BASKET}"

                        cd "${IN_BASKET}"
                        echo "[DEBUG] Changed to: $(pwd)"
                        echo "[DEBUG] Directory listing:"
                        ls -la
                        echo ""

                        # Find all documents (not DO_NOT_REMOVE_ME)
                        echo "[DEBUG] Searching for documents (excluding DO_NOT_REMOVE_ME)..."
                        DOC_COUNT=$(find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | wc -l)
                        echo "‚úì Found ${DOC_COUNT} document(s) in in_basket"

                        if [ ${DOC_COUNT} -gt 0 ]; then
                            echo ""
                            echo "Documents ready for processing:"
                            find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                                echo "  - $(basename "$doc") ($(stat -c%s "$doc" 2>/dev/null || stat -f%z "$doc" 2>/dev/null) bytes)"
                            done
                        else
                            echo "[WARN] No documents found in in_basket"
                        fi

                        echo "[DEBUG] Writing DOC_COUNT=${DOC_COUNT} to /tmp/doc_count"
                        echo "${DOC_COUNT}" > /tmp/doc_count
                        echo "[DEBUG] Contents of /tmp/doc_count: $(cat /tmp/doc_count)"
                        echo "========== END SCAN IN_BASKET =========="
                        echo ""
                    '''

                    env.DOC_COUNT = readFile('/tmp/doc_count').trim()
                }
            }
        }

        stage('Process Documents') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üì¶ Processing ${DOC_COUNT} document(s)..."

                    sh '''
                        cd "${IN_BASKET}"

                        # Process each document
                        find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort | while read doc; do
                            doc_name=$(basename "$doc")
                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Processing: ${doc_name}"

                            # For now, just log that we found the document
                            # Full processing logic to be implemented in next stage
                            echo "  Status: Queued for disposition"
                        done
                    '''
                }
            }
        }

        stage('Classify & Extract Metadata') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üî¨ Using Claude to classify documents and extract metadata..."

                    sh '''#!/bin/bash
                        echo "========== CLASSIFY & EXTRACT METADATA =========="
                        cd "${IN_BASKET}"
                        echo "[DEBUG] Working directory: $(pwd)"

                        # Create temporary metadata directory
                        echo "[DEBUG] Creating metadata directory: /tmp/disposition-metadata"
                        mkdir -p /tmp/disposition-metadata
                        echo "[DEBUG] Directory created. Contents:"
                        ls -la /tmp/disposition-metadata

                        # Read each document and use Claude to classify
                        echo "[DEBUG] Finding documents..."
                        DOC_FILES=$(find . -maxdepth 1 -type f ! -name "DO_NOT_REMOVE_ME" | sort)
                        FILE_COUNT=$(echo "${DOC_FILES}" | wc -l)
                        echo "[DEBUG] Found ${FILE_COUNT} document(s)"
                        echo "${DOC_FILES}"

                        echo "${DOC_FILES}" | while read doc; do
                            doc_name=$(basename "$doc")
                            doc_path="${IN_BASKET}/${doc_name}"

                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Analyzing: ${doc_name}"
                            echo "[DEBUG] Document path: ${doc_path}"
                            echo "[DEBUG] File exists: $(test -f "${doc_path}" && echo 'YES' || echo 'NO')"
                            echo "[DEBUG] File size: $(stat -c%s "${doc_path}" 2>/dev/null || stat -f%z "${doc_path}" 2>/dev/null) bytes"

                            # Classify document based on filename pattern
                            echo "  ‚Üí Classifying document based on filename..."

                            # Extract document type from filename (e.g., CAPA-001.adoc ‚Üí CAPA)
                            if [[ "${doc_name}" =~ ^([A-Z]+)-[0-9]+ ]]; then
                                DOC_TYPE="${BASH_REMATCH[1]}"
                                echo "[DEBUG] Regex matched - DOC_TYPE: ${DOC_TYPE}"
                            else
                                DOC_TYPE="UNKNOWN"
                                echo "[DEBUG] Regex did not match - DOC_TYPE: UNKNOWN"
                            fi

                            # Extract title from filename (remove extension)
                            DOC_TITLE="${doc_name%.*}"
                            echo "[DEBUG] DOC_TITLE: ${DOC_TITLE}"

                            # Determine format from extension
                            if [[ "${doc_name}" =~ [.]adoc$ ]]; then
                                FORMAT="asciidoc"
                            elif [[ "${doc_name}" =~ [.](md|markdown)$ ]]; then
                                FORMAT="markdown"
                            elif [[ "${doc_name}" =~ [.]pdf$ ]]; then
                                FORMAT="pdf"
                            else
                                FORMAT="other"
                            fi
                            echo "[DEBUG] FORMAT: ${FORMAT}"

                            # Create metadata JSON with simple classification
                            echo "[DEBUG] Creating metadata file: /tmp/disposition-metadata/${doc_name}.json"
                            cat > "/tmp/disposition-metadata/${doc_name}.json" << METADATA
{
  "type": "${DOC_TYPE}",
  "title": "${DOC_TITLE}",
  "required_signers": ["rajames440"],
  "format": "${FORMAT}",
  "needs_conversion": false
}
METADATA

                            # Display results
                            if [ -f "/tmp/disposition-metadata/${doc_name}.json" ]; then
                                echo "[DEBUG] Metadata file created successfully"
                                echo "[DEBUG] Metadata file contents:"
                                cat "/tmp/disposition-metadata/${doc_name}.json"

                                DOC_TYPE=$(jq -r '.type // "UNKNOWN"' "/tmp/disposition-metadata/${doc_name}.json")
                                DOC_TITLE=$(jq -r '.title // ""' "/tmp/disposition-metadata/${doc_name}.json")
                                SIGNERS=$(jq -r '.required_signers // []' "/tmp/disposition-metadata/${doc_name}.json")

                                echo "  Type: ${DOC_TYPE}"
                                echo "  Title: ${DOC_TITLE}"
                                echo "  Signers Required: ${SIGNERS}"
                            else
                                echo "[ERROR] Failed to create metadata file!"
                            fi
                        done

                        echo ""
                        echo "[DEBUG] All metadata files created:"
                        ls -la /tmp/disposition-metadata/
                        echo "========== END CLASSIFY & EXTRACT METADATA =========="
                        echo ""
                    '''
                }
            }
        }

        stage('Verify Git Status') {
            steps {
                script {
                    echo "‚úì Verifying git status..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Check git config
                        echo "Git configuration:"
                        git config user.name || echo "  user.name not set"
                        git config user.email || echo "  user.email not set"

                        # Show current branch
                        echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"

                        # Show status
                        echo "Status:"
                        git status --short | head -20
                    '''
                }
            }
        }

        stage('Convert Formats & Add Signatures') {
            when {
                expression { env.DOC_COUNT != "0" }
            }
            steps {
                script {
                    echo "üîÑ Converting formats to AsciiDoc and adding signature blocks..."

                    sh '''#!/bin/bash
                        cd "${IN_BASKET}"

                        # Process each document metadata
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)
                            doc_path="${IN_BASKET}/${doc_name}"
                            metadata=$(cat "${metadata_file}")

                            echo "Processing metadata for: ${doc_name}"

                            # Check if format conversion needed
                            NEEDS_CONVERSION=$(echo "${metadata}" | jq -r '.needs_conversion // false')
                            FORMAT=$(echo "${metadata}" | jq -r '.format // "unknown"')
                            DOC_TYPE=$(echo "${metadata}" | jq -r '.type // "UNKNOWN"')

                            if [ "${NEEDS_CONVERSION}" = "true" ] && [ "${FORMAT}" != "asciidoc" ]; then
                                echo "  ‚Üí Converting from ${FORMAT} to AsciiDoc..."

                                # Use Claude to convert document format
                                DOC_CONTENT=$(cat "${doc_path}")
                                claude --print "Convert this ${FORMAT} document to AsciiDoc format. Preserve all content, structure, and meaning. Output ONLY the AsciiDoc content, no explanations.

\\${DOC_CONTENT}" \
                                    > "${doc_path}.asciidoc" 2>&1 || {
                                    echo "  ‚ö†Ô∏è Conversion failed for ${doc_name}"
                                    continue
                                }

                                # Replace original with converted version
                                mv "${doc_path}.asciidoc" "${doc_path}"
                                echo "  ‚úì Converted to AsciiDoc"
                            fi

                            # Add signature block if controlled document (use bash, not Claude)
                            if [[ ! "${DOC_TYPE}" =~ ^(ART|MIN|REL|RMP)$ ]]; then
                                echo "  ‚Üí Adding signature block..."

                                # Build signature rows from metadata
                                SIGNERS=$(echo "${metadata}" | jq -r '.required_signers[]')
                                SIGNER_ROWS=""
                                while IFS= read -r signer; do
                                    SIGNER_ROWS="${SIGNER_ROWS}| ${signer} | Pending |  |
"
                                done <<< "${SIGNERS}"

                                # Append signature block to document (simple bash append, no Claude)
                                cat >> "${doc_path}" << SIGBLOCK

== Signatures

|===
| Signer | Status | Date | Signature

${SIGNER_ROWS}|===
SIGBLOCK

                                if [ $? -eq 0 ]; then
                                    echo "  ‚úì Signature block added"
                                else
                                    echo "  ‚ö†Ô∏è Signature block addition failed"
                                fi
                            fi
                        done
                    '''
                }
            }
        }

        stage('Route to Pending') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìÇ Routing processed documents to Pending/[TYPE]/ directories..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Create Pending directory if it doesn't exist
                        mkdir -p Pending

                        # Process each document from metadata
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)
                            doc_path="${IN_BASKET}/${doc_name}"

                            if [ ! -f "${doc_path}" ]; then
                                echo "‚ö†Ô∏è Document not found: ${doc_name}"
                                continue
                            fi

                            # Extract document type from metadata
                            DOC_TYPE=$(jq -r '.type // "UNKNOWN"' "${metadata_file}")
                            DOC_TITLE=$(jq -r '.title // ""' "${metadata_file}")

                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Routing: ${doc_name}"
                            echo "  Type: ${DOC_TYPE}"
                            echo "  Title: ${DOC_TITLE}"

                            # Create type-specific pending directory
                            PENDING_TYPE_DIR="Pending/${DOC_TYPE}"
                            mkdir -p "${PENDING_TYPE_DIR}"

                            # Copy document to Pending directory
                            cp "${doc_path}" "${PENDING_TYPE_DIR}/${doc_name}"

                            if [ $? -eq 0 ]; then
                                # Save document type and title for later use
                                echo "${DOC_TYPE}" > "/tmp/doc-${doc_name}.type"
                                echo "${DOC_TITLE}" > "/tmp/doc-${doc_name}.title"
                                echo "  ‚úì Routed to Pending/${DOC_TYPE}/"
                            else
                                echo "  ‚ö†Ô∏è Failed to route document"
                            fi
                        done
                    '''
                }
            }
        }

        stage('Create Feature Branch') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üåø Creating feature branch for document processing..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Create a single branch for this disposition batch
                        BRANCH_NAME="doc/disposition-$(date +%s)"

                        git checkout -b "${BRANCH_NAME}"
                        echo "Created branch: ${BRANCH_NAME}"
                        echo "${BRANCH_NAME}" > /tmp/branch_name
                    '''

                    env.BRANCH_NAME = readFile('/tmp/branch_name').trim()
                }
            }
        }

        stage('Create Routing PR (PR #1)') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìã Creating internal PR #1: Document routing to Pending/..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Set git configuration for commits
                        git config user.name "${GIT_AUTHOR_NAME}"
                        git config user.email "${GIT_AUTHOR_EMAIL}"

                        # Stage all Pending directory changes
                        git add Pending/

                        # Check if there are changes to commit
                        if git diff --cached --quiet; then
                            echo "‚ÑπÔ∏è No changes to commit (DRY_RUN or no documents routed)"
                        else
                            # Create commit with timestamp
                            git commit -m "docs(disposition): Route ${DOC_COUNT} document(s) to Pending/

- Processing timestamp: ${TIMESTAMP}
- Documents ready for signature collection
- PR #1 of 4: Initial routing to workflow

[Disposition Pipeline]"

                            echo "‚úì PR #1 commit created: $(git rev-parse --short HEAD)"
                            git log --oneline -1
                        fi
                    '''
                }
            }
        }

        stage('Notify Signers') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìß Notifying required signers via GitHub..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        # Process each document to identify signers
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)

                            # Extract signers from metadata
                            SIGNERS=$(jq -r '.required_signers[]?' "${metadata_file}")
                            DOC_TITLE=$(jq -r '.title // ""' "${metadata_file}")
                            DOC_TYPE=$(jq -r '.type // "UNKNOWN"' "${metadata_file}")

                            if [ -z "${SIGNERS}" ]; then
                                echo "‚ÑπÔ∏è No signers required for: ${doc_name}"
                                continue
                            fi

                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "üì¢ Notifying signers for: ${doc_name}"
                            echo "   Title: ${DOC_TITLE}"
                            echo "   Type: ${DOC_TYPE}"
                            echo "   Signers:"

                            # Build list of signers with @ mentions
                            SIGNER_MENTIONS=""
                            echo "${SIGNERS}" | while read signer; do
                                echo "     - ${signer}"
                                SIGNER_MENTIONS="${SIGNER_MENTIONS}@${signer} "
                            done

                            # Create GitHub issue notification
                            if command -v gh &> /dev/null; then
                                echo "  ‚Üí Creating GitHub issue notification..."

                                # Build signer list for the issue
                                SIGNERS_LIST=$(echo "${SIGNERS}" | sed 's/^/- @/')

                                # Write issue body to temp file (pure bash, no Groovy parsing)
                                cat > /tmp/issue_body.txt << 'ISSUE_EOF'
Document pending signature collection.

**Document:** `DOCUMENT_NAME_PLACEHOLDER`
**Type:** DOCUMENT_TYPE_PLACEHOLDER
**Title:** DOCUMENT_TITLE_PLACEHOLDER

**Required Signers:**
SIGNERS_PLACEHOLDER

**Action Required:**
1. Review document in `Pending/DOCUMENT_TYPE_PLACEHOLDER/DOCUMENT_NAME_PLACEHOLDER`
2. Sign with GPG: `gpg --detach-sign --armor DOCUMENT_NAME_PLACEHOLDER`
3. Create detached signature: `DOCUMENT_NAME_PLACEHOLDER.[your-username].asc`
4. Commit to repository or notify pipeline

**Timeline:**
- Day 1: Reminder notification
- Day 3: PM escalation if not signed

Created: TIMESTAMP_PLACEHOLDER
Branch: BRANCH_PLACEHOLDER
ISSUE_EOF

                                # Replace placeholders with actual values using bash
                                sed -i "s|DOCUMENT_NAME_PLACEHOLDER|${doc_name}|g" /tmp/issue_body.txt
                                sed -i "s|DOCUMENT_TYPE_PLACEHOLDER|${DOC_TYPE}|g" /tmp/issue_body.txt
                                sed -i "s|DOCUMENT_TITLE_PLACEHOLDER|${DOC_TITLE}|g" /tmp/issue_body.txt
                                sed -i "s|SIGNERS_PLACEHOLDER|${SIGNERS_LIST}|g" /tmp/issue_body.txt
                                sed -i "s|TIMESTAMP_PLACEHOLDER|${TIMESTAMP}|g" /tmp/issue_body.txt
                                sed -i "s|BRANCH_PLACEHOLDER|${BRANCH_NAME}|g" /tmp/issue_body.txt

                                # Read the file into a variable
                                ISSUE_BODY=$(cat /tmp/issue_body.txt)

                                gh issue create \
                                  --title "üìã Document Pending Signature: ${doc_name}" \
                                  --body "${ISSUE_BODY}" \
                                  --label "governance,signature-needed" \
                                  --assignee ${SIGNERS} 2>&1 || {
                                    echo "  ‚ö†Ô∏è GitHub issue creation may have failed (check below)"
                                }

                                echo "  ‚úì GitHub issue created and signers assigned"
                            else
                                echo "  ‚ö†Ô∏è gh CLI not available, falling back to notification log"
                                echo "[NOTIFY] GitHub Issue: ${doc_name}" >> /tmp/notification-log
                                echo "${SIGNERS}" | while read signer; do
                                    echo "[NOTIFY] @${signer}: Please sign ${doc_name}" >> /tmp/notification-log
                                done
                            fi
                        done

                        # Summary
                        if [ -f /tmp/notification-log ]; then
                            echo ""
                            echo "Notification Summary:"
                            cat /tmp/notification-log
                        fi
                    '''
                }
            }
        }

        stage('Setup Escalation Tracking') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "‚è∞ Setting up escalation tracking for pending documents..."

                    sh '''
                        # Create escalation tracking directory
                        mkdir -p "${WORKSPACE_REPO}/Security/Escalations"

                        # Process each document
                        find /tmp/disposition-metadata -name "*.json" | sort | while read metadata_file; do
                            doc_name=$(basename "${metadata_file}" .json)
                            DOC_TITLE=$(jq -r '.title // ""' "${metadata_file}")
                            DOC_TYPE=$(jq -r '.type // ""' "${metadata_file}")
                            SIGNERS=$(jq -r '.required_signers[]?' "${metadata_file}")

                            echo "Setting up escalation for: ${doc_name}"

                            # Create escalation tracking file
                            ESCALATION_FILE="${WORKSPACE_REPO}/Security/Escalations/${doc_name}.escalation"
                            cat > "${ESCALATION_FILE}" << ESCALATION
# Escalation Tracking: ${doc_name}
title: ${DOC_TITLE}
type: ${DOC_TYPE}
routed_at: ${TIMESTAMP}
day1_reminder: $(date -u -d '+1 day' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v+1d +%Y-%m-%dT%H:%M:%SZ)
day3_escalate_pm: $(date -u -d '+3 days' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v+3d +%Y-%m-%dT%H:%M:%SZ)
signers_required:
${SIGNERS:+$(echo "${SIGNERS}" | sed 's/^/  - /')}
status: PENDING_SIGNATURES
ESCALATION

                            if [ -f "${ESCALATION_FILE}" ]; then
                                echo "  ‚úì Escalation tracking created"
                            fi
                        done

                        # List all tracked escalations
                        echo ""
                        echo "Active Escalations:"
                        ls -la "${WORKSPACE_REPO}/Security/Escalations/" 2>/dev/null | tail -n +4 || echo "  (none)"
                    '''
                }
            }
        }

        stage('Update Security Log') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üîê Updating Security Event Log..."

                    sh '''
                        SEC_LOG="${WORKSPACE_REPO}/Security/SEC_LOG.adoc"

                        if [ ! -f "${SEC_LOG}" ]; then
                            echo "‚ö†Ô∏è Security log not found at ${SEC_LOG}"
                            exit 0
                        fi

                        # Append disposition events to security log
                        cat >> "${SEC_LOG}" << LOG_ENTRY

== Disposition Event: ${TIMESTAMP}

[cols="1,3"]
|===
|Event|${DOC_COUNT} document(s) routed to Pending
|Branch|${BRANCH_NAME}
|Status|PENDING_SIGNATURES
|Action|Awaiting required signatures or PM override
|===

LOG_ENTRY

                        echo "‚úì Security log updated"
                    '''
                }
            }
        }

        stage('Commit Workflow Changes') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üíæ Committing workflow state changes..."

                    sh '''
                        cd "${WORKSPACE_REPO}"

                        git config user.name "${GIT_AUTHOR_NAME}"
                        git config user.email "${GIT_AUTHOR_EMAIL}"

                        # Stage escalation and log changes
                        git add Security/Escalations/ || true
                        git add Security/SEC_LOG.adoc || true

                        if ! git diff --cached --quiet; then
                            git commit -m "docs(disposition): Update escalation tracking and security log

- Setup Day 1 reminder and Day 3 PM escalation tracking
- Record disposition event in Security Event Log
- Timestamp: ${TIMESTAMP}
- Branch: ${BRANCH_NAME}

[Disposition Pipeline - Escalation Setup]"

                            echo "‚úì Workflow changes committed"
                        else
                            echo "‚ÑπÔ∏è No workflow changes to commit"
                        fi
                    '''
                }
            }
        }

        stage('Push to GitHub') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üöÄ Pushing disposition changes to GitHub..."

                    withCredentials([usernamePassword(credentialsId: 'github-credentials', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')]) {
                        sh '''
                            cd "${WORKSPACE_REPO}"

                            echo "[DEBUG] Configuring git credentials for push..."
                            # Configure git to use the token for authentication
                            git config credential.helper store
                            echo "https://${GIT_USER}:${GIT_TOKEN}@github.com" > ~/.git-credentials
                            chmod 600 ~/.git-credentials
                            echo "[DEBUG] Git credentials configured"

                            # Check if there are commits to push
                            COMMITS=$(git rev-list origin/master..HEAD 2>/dev/null | wc -l)
                            echo "[DEBUG] Commits to push: ${COMMITS}"

                            if [ "${COMMITS}" -eq 0 ]; then
                                echo "‚ÑπÔ∏è No commits to push"
                                exit 0
                            fi

                            echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"
                            echo "[DEBUG] Pushing branch: ${BRANCH_NAME}"

                            # Push feature branch to GitHub
                            git push -u origin "${BRANCH_NAME}" 2>&1

                            if [ $? -eq 0 ]; then
                                echo "‚úì Branch pushed: ${BRANCH_NAME}"
                            else
                                echo "‚ö†Ô∏è Failed to push branch"
                                exit 1
                            fi

                            # Show commits to be merged to master
                            echo ""
                            echo "Commits ready for master:"
                            git log --oneline origin/master..HEAD | head -10

                            # Clean up credentials
                            echo "[DEBUG] Cleaning up git credentials..."
                            rm -f ~/.git-credentials
                        '''
                    }
                }
            }
        }

        stage('Summary') {
            steps {
                script {
                    echo ""
                    echo "üìä Disposition Pipeline Summary"
                    echo "===================================="
                    echo "Execution:     ${TIMESTAMP}"
                    echo "Documents:     ${DOC_COUNT}"
                    if (env.BRANCH_NAME) {
                        echo "Branch:        ${BRANCH_NAME}"
                    }
                    echo ""
                    echo "Pipeline Stages:"
                    echo "  ‚úì Scanned in_basket"
                    echo "  ‚úì Classified documents"
                    echo "  ‚úì Converted formats & added signatures"
                    echo "  ‚úì Routed to Pending/[TYPE]/"
                    echo "  ‚úì Created PR #1 (routing)"
                    echo "  ‚úì Notified signers"
                    echo "  ‚úì Setup escalation tracking"
                    echo "  ‚úì Updated security log"
                    echo ""
                    if (params.DRY_RUN) {
                        echo "Mode:          DRY RUN (no commits/pushes)"
                    } else {
                        echo "Mode:          LIVE (changes committed & pushed)"
                    }
                    echo ""
                    echo "Next Steps:"
                    echo "  ‚Üí Signers verify and sign documents in Pending/[TYPE]/"
                    echo "  ‚Üí Day 1: Reminder notification sent"
                    echo "  ‚Üí Day 3: PM escalation for unsigned documents"
                    echo "  ‚Üí Upon completion: Create PR #4 (move to vault)"
                    echo "===================================="
                }
            }
        }
    }

    post {
        always {
            script {
                echo "‚úÖ Pipeline execution complete"
                echo "Build Status: ${currentBuild.result}"
            }
        }

        success {
            script {
                echo "‚úì Documents processed successfully"
            }
        }

        failure {
            script {
                echo "‚ùå Pipeline encountered errors"
            }
        }
    }
}
