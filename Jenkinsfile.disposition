// Jenkinsfile.disposition - PRODUCTION
// Document Disposition Pipeline - Pure Groovy Business Logic
// All file operations, logic, and data processing in Groovy DSL
// External tools (git, gh) called as needed

@Library('shared-library') _

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Dry run mode (no commits/pushes)'
        )
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '50'))
        timeout(time: 2, unit: 'HOURS')
        disableConcurrentBuilds()
        timestamps()
    }

    environment {
        GOVERNANCE_REPO = 'rajames440/StarForth-Governance'
        WORKSPACE_REPO = "${WORKSPACE}"
        TIMESTAMP = new Date().format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'')
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "üìã Checking out StarForth-Governance repository..."
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/master']],
                        userRemoteConfigs: [[
                            url: "https://github.com/${env.GOVERNANCE_REPO}.git",
                            credentialsId: 'github-credentials'
                        ]]
                    ])
                }
            }
        }

        stage('Scan & Classify') {
            steps {
                script {
                    echo "üîç Scanning in_basket and classifying documents..."

                    try {
                        // Groovy-based document scanning and classification
                        def inBasketDir = new File("${env.WORKSPACE}/in_basket")
                        def metadataDir = new File('/tmp/disposition-metadata')
                        def hintsDir = new File('/tmp/disposition-hints')

                        // Ensure output directories exist
                        metadataDir.mkdirs()
                        hintsDir.mkdirs()

                        // Find all documents (exclude DO_NOT_REMOVE_ME)
                        def documents = inBasketDir.listFiles({ file ->
                            file.isFile() && file.name != 'DO_NOT_REMOVE_ME'
                        } as FileFilter)?.sort { it.name } ?: []

                        env.DOC_COUNT = documents.size().toString()
                        echo "‚úì Found ${env.DOC_COUNT} document(s) in in_basket"

                        if (documents.isEmpty()) {
                            echo "[WARN] No documents to process"
                            return
                        }

                        // Process each document
                        documents.each { File docFile ->
                            String docName = docFile.name
                            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                            echo "Processing: ${docName}"

                            try {
                                // Read document content
                                String docContent = docFile.text
                                String docContentLower = docContent.toLowerCase()

                                // Determine format
                                String format = 'other'
                                if (docName.endsWith('.adoc') || docName.endsWith('.asciidoc')) {
                                    format = 'asciidoc'
                                } else if (docName.endsWith('.md') || docName.endsWith('.markdown')) {
                                    format = 'markdown'
                                } else if (docName.endsWith('.pdf')) {
                                    format = 'pdf'
                                }

                                // Extract document type from content (multiple patterns)
                                String docType = extractDocumentType(docContent, docContentLower, docName, format)
                                String docTitle = extractDocumentTitle(docContent, docName, format)
                                List<String> requiredSigners = extractSigners(docContent, docContentLower)

                                echo "  Type: ${docType}"
                                echo "  Title: ${docTitle}"
                                echo "  Signers: ${requiredSigners.join(', ')}"

                                // Create metadata file
                                Map metadata = [
                                    type: docType,
                                    title: docTitle,
                                    required_signers: requiredSigners,
                                    format: format,
                                    needs_conversion: format != 'asciidoc'
                                ]

                                File metadataFile = new File(metadataDir, "${docName}.json")
                                metadataFile.text = groovy.json.JsonOutput.prettyPrint(
                                    groovy.json.JsonOutput.toJson(metadata)
                                )

                                // Extract quality & governance keywords
                                Map hints = extractKeywordHints(docContentLower)
                                File hintsFile = new File(hintsDir, "${docName}.hints")
                                hintsFile.text = groovy.json.JsonOutput.prettyPrint(
                                    groovy.json.JsonOutput.toJson(hints)
                                )

                                echo "  ‚úì Metadata and hints created"

                            } catch (Exception e) {
                                echo "  ‚ùå Failed to process: ${e.message}"
                            }
                        }

                    } catch (Exception e) {
                        echo "‚ùå CRITICAL ERROR in Scan & Classify: ${e.message}"
                        throw e
                    }
                }
            }
        }

        stage('Route to Pending') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìÇ Routing documents to Pending/[TYPE]/ directories..."

                    try {
                        def inBasketDir = new File("${env.WORKSPACE}/in_basket")
                        def pendingDir = new File("${env.WORKSPACE}/Pending")
                        def metadataDir = new File('/tmp/disposition-metadata')
                        def hintsDir = new File('/tmp/disposition-hints')

                        pendingDir.mkdirs()

                        def metadataFiles = metadataDir.listFiles({ file ->
                            file.name.endsWith('.json')
                        } as FileFilter)?.sort { it.name } ?: []

                        int routed = 0
                        int failed = 0

                        metadataFiles.each { File metadataFile ->
                            String docName = metadataFile.name.replaceAll('\\.json$', '')
                            File docPath = new File(inBasketDir, docName)

                            echo "Processing: ${docName}"

                            try {
                                if (!docPath.exists()) {
                                    echo "  ‚ö†Ô∏è Document not found (may be already routed)"
                                    return
                                }

                                // Parse metadata
                                def metadata = new groovy.json.JsonSlurper().parse(metadataFile)
                                String docType = metadata.get('type', 'UNKNOWN')

                                // Create pending directory
                                File pendingTypeDir = new File(pendingDir, docType)
                                pendingTypeDir.mkdirs()

                                // Add signature block if needed
                                if (!['ART', 'MIN', 'REL', 'RMP'].contains(docType)) {
                                    String sigBlock = buildSignatureBlock(metadata)
                                    docPath.append('\n' + sigBlock)
                                    echo "  ‚úì Signature block added"
                                }

                                // Move document
                                File destFile = new File(pendingTypeDir, docName)
                                if (docPath.renameTo(destFile)) {
                                    echo "  ‚úì Routed to Pending/${docType}/"
                                    routed++

                                    // Check hints
                                    File hintsFile = new File(hintsDir, "${docName}.hints")
                                    if (hintsFile.exists()) {
                                        def hints = new groovy.json.JsonSlurper().parse(hintsFile)
                                        if (hints.hold_if_found) {
                                            File holdDir = new File("${env.WORKSPACE}/Hold", docType)
                                            holdDir.mkdirs()
                                            File holdDest = new File(holdDir, docName)
                                            if (destFile.renameTo(holdDest)) {
                                                echo "  ‚ö†Ô∏è HOLD: Document moved to Hold/${docType}/"
                                            }
                                        }
                                        if (hints.escalate) {
                                            echo "  üö® ESCALATE: PM escalation flagged"
                                        }
                                    }
                                } else {
                                    echo "  ‚ùå Failed to move document"
                                    failed++
                                }

                            } catch (Exception e) {
                                echo "  ‚ùå Error: ${e.message}"
                                failed++
                            }
                        }

                        echo ""
                        echo "Routing Summary: ${routed} routed, ${failed} failed"

                    } catch (Exception e) {
                        echo "‚ùå CRITICAL ERROR in Route to Pending: ${e.message}"
                        throw e
                    }
                }
            }
        }

        stage('Create Feature Branch') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üåø Creating feature branch..."
                    sh '''
                        cd "${WORKSPACE_REPO}"
                        git config user.name "Disposition Pipeline"
                        git config user.email "disposition@starforth.governance"
                        BRANCH_NAME="doc/disposition-$(date +%s)"
                        git checkout -b "${BRANCH_NAME}"
                        echo "${BRANCH_NAME}" > /tmp/branch_name
                    '''
                    env.BRANCH_NAME = readFile('/tmp/branch_name').trim()
                    echo "‚úì Branch: ${env.BRANCH_NAME}"
                }
            }
        }

        stage('Commit & Push') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üíæ Committing and pushing changes..."

                    sh '''
                        cd "${WORKSPACE_REPO}"
                        git add Pending/ Hold/ Security/ || true

                        if ! git diff --cached --quiet; then
                            git commit -m "docs(disposition): Route ${DOC_COUNT} document(s) to Pending/

- Timestamp: ${TIMESTAMP}
- Branch: ${BRANCH_NAME}
- Documents classified and routed for signature collection

[Disposition Pipeline]"

                            git push -u origin "${BRANCH_NAME}"
                            echo "‚úì Changes pushed"
                        else
                            echo "‚ÑπÔ∏è No changes to commit"
                        fi
                    '''
                }
            }
        }

        stage('Notify Signers') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üìß Notifying signers via GitHub..."

                    try {
                        def metadataDir = new File('/tmp/disposition-metadata')
                        def metadataFiles = metadataDir.listFiles({ file ->
                            file.name.endsWith('.json')
                        } as FileFilter) ?: []

                        metadataFiles.each { File mf ->
                            def metadata = new groovy.json.JsonSlurper().parse(mf)
                            String docName = mf.name.replaceAll('\\.json$', '')
                            String docType = metadata.type
                            String docTitle = metadata.title
                            List signers = metadata.required_signers ?: []

                            if (signers.isEmpty()) return

                            echo "Creating GitHub issue for: ${docName}"

                            String issueBody = """Document pending signature collection.

**Document:** ${docName}
**Type:** ${docType}
**Title:** ${docTitle}

**Required Signers:** ${signers.join(', ')}

**Action Required:**
1. Review document in Pending/${docType}/${docName}
2. Sign with GPG: gpg --detach-sign --armor ${docName}
3. Create signature: ${docName}.[your-username].asc
4. Commit and push

**Timeline:**
- Day 1: Reminder
- Day 3: PM escalation

Created: ${env.TIMESTAMP}
Branch: ${env.BRANCH_NAME}"""

                            sh """
                                cd "${env.WORKSPACE_REPO}"
                                gh issue create \\
                                  --title "üìã Document Pending Signature: ${docName}" \\
                                  --body "${issueBody.replace('"', '\\"')}" \\
                                  --label "governance,signature-needed" \\
                                  --assignee ${signers.join(',')} 2>/dev/null || echo "‚ö†Ô∏è Issue creation failed"
                            """
                        }

                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Notification error (non-blocking): ${e.message}"
                    }
                }
            }
        }

        stage('Setup Escalation') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "‚è∞ Setting up escalation tracking..."

                    try {
                        def metadataDir = new File('/tmp/disposition-metadata')
                        def escalationDir = new File("${env.WORKSPACE}/Security/Escalations")
                        escalationDir.mkdirs()

                        def metadataFiles = metadataDir.listFiles({ file ->
                            file.name.endsWith('.json')
                        } as FileFilter) ?: []

                        metadataFiles.each { File mf ->
                            def metadata = new groovy.json.JsonSlurper().parse(mf)
                            String docName = mf.name.replaceAll('\\.json$', '')
                            String docType = metadata.type
                            String docTitle = metadata.title
                            List signers = metadata.required_signers ?: []

                            // Calculate dates
                            Date now = new Date()
                            Date day1 = new Date(now.time + (1000 * 60 * 60 * 24))
                            Date day3 = new Date(now.time + (1000 * 60 * 60 * 24 * 3))

                            String escalationContent = """# Escalation Tracking: ${docName}
type: ${docType}
title: ${docTitle}
routed_at: ${env.TIMESTAMP}
day1_reminder: ${day1.format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'')}
day3_escalate_pm: ${day3.format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'')}
signers_required:
${signers.collect { "  - ${it}" }.join('\n')}
status: PENDING_SIGNATURES
"""

                            File escalationFile = new File(escalationDir, "${docName}.escalation")
                            escalationFile.text = escalationContent
                        }

                        echo "‚úì Escalation tracking created"

                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Escalation setup error (non-blocking): ${e.message}"
                    }
                }
            }
        }

        stage('Update Security Log') {
            when {
                expression { env.DOC_COUNT != "0" && !params.DRY_RUN }
            }
            steps {
                script {
                    echo "üîê Updating security log..."

                    try {
                        File secLog = new File("${env.WORKSPACE}/Security/SEC_LOG.adoc")
                        if (!secLog.exists()) {
                            secLog.parentFile.mkdirs()
                            secLog.text = "= Security Event Log\n\n"
                        }

                        String logEntry = """
== Disposition Event: ${env.TIMESTAMP}

[cols="1,3"]
|===
|Event|${env.DOC_COUNT} document(s) routed to Pending
|Branch|${env.BRANCH_NAME}
|Status|PENDING_SIGNATURES
|Action|Awaiting required signatures or PM override
|===
"""

                        secLog.append(logEntry)
                        echo "‚úì Security log updated"

                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Security log error (non-blocking): ${e.message}"
                    }
                }
            }
        }

        stage('Summary') {
            steps {
                script {
                    echo ""
                    echo "üìä Disposition Pipeline Summary"
                    echo "===================================="
                    echo "Timestamp:     ${env.TIMESTAMP}"
                    echo "Documents:     ${env.DOC_COUNT}"
                    echo "Branch:        ${env.BRANCH_NAME ?: 'N/A'}"
                    echo "Mode:          ${params.DRY_RUN ? 'DRY RUN' : 'LIVE'}"
                    echo ""
                    echo "‚úì All documents classified and routed"
                    echo "‚úì Signers notified via GitHub issues"
                    echo "‚úì Escalation tracking created"
                    echo "‚úì Changes committed and pushed"
                    echo ""
                    echo "Next Steps:"
                    echo "  ‚Üí Signers review and sign documents in Pending/[TYPE]/"
                    echo "  ‚Üí Documents move to Hold/ if issues found"
                    echo "  ‚Üí PM escalation on Day 3 for unsigned docs"
                    echo "===================================="
                }
            }
        }
    }

    post {
        always {
            script {
                echo "‚úÖ Pipeline execution complete"
            }
        }

        success {
            script {
                if (env.DOC_COUNT != "0" && !params.DRY_RUN) {
                    mail(
                        subject: "‚úì Disposition Pipeline Success - ${env.DOC_COUNT} document(s)",
                        body: "Documents processed successfully. Branch: ${env.BRANCH_NAME}",
                        to: "rajames440@gmail.com",
                        mimeType: 'text/plain'
                    )
                }
            }
        }

        failure {
            script {
                mail(
                    subject: "‚ùå Disposition Pipeline FAILED",
                    body: "Check Jenkins logs: ${env.BUILD_URL}console",
                    to: "rajames440@gmail.com",
                    mimeType: 'text/plain'
                )
            }
        }
    }
}

// ============ HELPER FUNCTIONS ============

String extractDocumentType(String content, String contentLower, String docName, String format) {
    // Pattern 1: Document ID field
    if (content =~ /\*\*Document ID:\*\*\s*\[([A-Z]+)-([0-9]+-[0-9]+)\]/) {
        def match = content =~ /\*\*Document ID:\*\*\s*\[([A-Z]+)-/
        if (match) return match[0][1]
    }

    // Pattern 2: Classification checkbox
    if (content =~ /\[x\]\s*\*\*([A-Z]+)\*\*/) {
        def match = content =~ /\[x\]\s*\*\*([A-Z]+)\*\*/
        if (match) return match[0][1]
    }

    // Pattern 3: Keyword inference
    if (contentLower.contains('failure') && contentLower.contains('mode')) return 'FMEA'
    if (contentLower.contains('engineering') && contentLower.contains('change') && contentLower.contains('request')) return 'ECR'
    if (contentLower.contains('engineering') && contentLower.contains('change') && contentLower.contains('order')) return 'ECO'
    if (contentLower.contains('corrective') || contentLower.contains('preventive')) return 'CAPA'
    if (contentLower.contains('security') && contentLower.contains('review')) return 'SEC'

    // Fallback: filename pattern
    if (docName =~ /^([A-Z]+)-[0-9]+/) {
        def match = docName =~ /^([A-Z]+)-/
        if (match) return match[0][1]
    }

    return 'UNKNOWN'
}

String extractDocumentTitle(String content, String docName, String format) {
    // Try to get title from heading
    if (format == 'markdown' && content =~ /^#+\s+(.+)$/) {
        def match = content =~ /^#+\s+(.+)$/
        if (match) return match[0][1]
    }

    if (content =~ /^=\s+(.+)$/) {
        def match = content =~ /^=\s+(.+)$/
        if (match) return match[0][1]
    }

    // Fallback to filename
    return docName.replaceAll('\\.[^.]+$', '')
}

List<String> extractSigners(String content, String contentLower) {
    List<String> signers = []

    // Look for "Submitted by:" field
    if (content =~ /\*\*Submitted by:\*\*\s*\[([^\]]+)\]/) {
        def match = content =~ /\*\*Submitted by:\*\*\s*\[([^\]]+)\]/
        if (match) {
            signers.add(match[0][1])
        }
    }

    // Default signer if none found
    if (signers.isEmpty()) {
        signers.add('rajames440')
    }

    return signers
}

Map extractKeywordHints(String contentLower) {
    Map hints = [
        escalate: false,
        pm_required: false,
        hold_if_found: false,
        additional_signers: '',
        found_categories: ''
    ]

    // Quality testing
    if (contentLower =~ /validation|verified|testing|test case|acceptance criteria/) {
        hints.found_categories += 'quality_testing;'
    }

    // Governance/Compliance
    if (contentLower =~ /governance|compliance|audit|policy|approval/) {
        hints.pm_required = true
        hints.found_categories += 'governance_compliance;'
    }

    // Risk Assessment
    if (contentLower =~ /risk|mitigation|severity/) {
        hints.escalate = true
        hints.pm_required = true
        hints.found_categories += 'risk_assessment;'
    }

    // Notes/TODOs
    if (contentLower =~ /todo|fixme|caveat|limitation/) {
        hints.hold_if_found = true
        hints.found_categories += 'notes_documentation;'
    }

    // Escalation/Priority
    if (contentLower =~ /urgent|blocker|deadline|critical/) {
        hints.escalate = true
        hints.pm_required = true
        hints.found_categories += 'escalation_priority;'
    }

    return hints
}

String buildSignatureBlock(Map metadata) {
    List signers = metadata.required_signers ?: ['rajames440']
    String signerRows = signers.collect { "| ${it} | Pending |  |" }.join('\n')

    return """
== Signatures

|===
| Signer | Status | Date | Signature

${signerRows}
|==="""
}