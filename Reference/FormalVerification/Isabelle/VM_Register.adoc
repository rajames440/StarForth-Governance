= VM_Register Theory - Formal Verification
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: rouge
:icons: font

[.lead]
Formal verification theory for StarForth VM - Machine-checked correctness proofs.

== Theory Overview

[cols="1,3"]
|===
| **Theory Name** | `VM_Register`
| **Generated** | 2025-10-30 08:34:25
| **Verification Status** | ✅ **VERIFIED** (Isabelle/HOL)
| **Imports** | 
| **Definitions** | 4
| **Lemmas/Theorems** | 17
| **Datatypes** | 1
|===

[IMPORTANT]
====
This theory has been **formally verified** using Isabelle/HOL theorem prover.
All proofs have been machine-checked and are mathematically sound.
====


== Theory Dependencies

This theory builds upon the following theories:


== Type Definitions

=== Datatypes and Type Synonyms

[source,isabelle]
----
type_synonym ('dict,'val,'io,'phys) word_dict =
----

These type definitions establish the foundational data structures used throughout the theory.

== Definitions & Functions

Core definitions that establish the semantics of the StarForth VM:

=== Definition

[source,isabelle]
----
fun lookup_word :: "string \<Rightarrow> ('d,'v,'i,'p) word_dict \<Rightarrow> (('d,'v stack,'i,'p) vm_core_state \<Rightarrow> ('d,'v stack,'i,'p) vm_core_state) option" where
  "lookup_word _ [] = None" |
  "lookup_word name ((n,f)#rest) = (if name = n then Some f else lookup_word name rest)"

----

=== Definition

[source,isabelle]
----
definition register_word :: "string \<Rightarrow> (('d,'v stack,'i,'p) vm_core_state \<Rightarrow> ('d,'v stack,'i,'p) vm_core_state) \<Rightarrow> ('d,'v,'i,'p) word_dict \<Rightarrow> ('d,'v,'i,'p) word_dict" where
  "register_word name f dict = (name, f) # dict"

----

=== Definition

[source,isabelle]
----
definition register_return_stack_words :: "('dict,'val,'io,'phys) word_dict \<Rightarrow> ('dict,'val,'io,'phys) word_dict" where
  "register_return_stack_words dict =
      register_word \"R@\" word_peek_return (
      register_word \"R>\" word_from_return (
      register_word \">R\" word_to_return dict))"

----

=== Definition

[source,isabelle]
----
definition register_data_stack_words :: "('dict,'val,'io,'phys) word_dict \<Rightarrow> ('dict,'val,'io,'phys) word_dict" where
  "register_data_stack_words dict =
      register_word \"ROLL\" word_roll (
      register_word \"PICK\" word_pick (
      register_word \"DEPTH\" word_depth (
      register_word \"-ROT\" word_minus_rot (
      register_word \"ROT\" word_rot (
      register_word \"OVER\" word_over (
      register_word \"SWAP\" word_swap (
      register_word \"?DUP\" word_qdup (
      register_word \"DUP\" word_dup (
      register_word \"DROP\" word_drop dict)))))))))"

----


== Lemmas & Theorems

[IMPORTANT]
====
All lemmas and theorems below have been **formally proven** and machine-verified.
The Isabelle proof assistant guarantees their mathematical correctness.
====

=== Lemma: `register_return_stack_words_to_r:`

[source,isabelle]
----
lemma register_return_stack_words_to_r:
  "lookup_word \">R\" (register_return_stack_words dict) = Some word_to_return"
  unfolding register_return_stack_words_def
  by (simp add: register_word_def)
----

✅ **Status:** PROVEN

=== Lemma: `register_return_stack_words_r_from:`

[source,isabelle]
----
lemma register_return_stack_words_r_from:
  "lookup_word \"R>\" (register_return_stack_words dict) = Some word_from_return"
  unfolding register_return_stack_words_def register_word_def
  by simp
----

✅ **Status:** PROVEN

=== Lemma: `register_return_stack_words_r_peek:`

[source,isabelle]
----
lemma register_return_stack_words_r_peek:
  "lookup_word \"R@\" (register_return_stack_words dict) = Some word_peek_return"
  unfolding register_return_stack_words_def
  by (simp add: register_word_def)
----

✅ **Status:** PROVEN


== Complete Theory Source

Below is the complete, verified source code of this theory:

[source,isabelle]
----
theory VM_Register
  imports VM_Words VM_DataStack_Words
begin

section \<open>Dictionary registration model\<close>

text \<open>
  We model the portion of the VM dictionary relevant to the return-stack
  words.  The model keeps only the word name together with the abstract
  semantic function (state → state).
\<close>

type_synonym ('dict,'val,'io,'phys) word_dict =
  "(string \<times> (('dict,'val stack,'io,'phys) vm_core_state \<Rightarrow> ('dict,'val stack,'io,'phys) vm_core_state)) list"

fun lookup_word :: "string \<Rightarrow> ('d,'v,'i,'p) word_dict \<Rightarrow> (('d,'v stack,'i,'p) vm_core_state \<Rightarrow> ('d,'v stack,'i,'p) vm_core_state) option" where
  "lookup_word _ [] = None" |
  "lookup_word name ((n,f)#rest) = (if name = n then Some f else lookup_word name rest)"

definition register_word :: "string \<Rightarrow> (('d,'v stack,'i,'p) vm_core_state \<Rightarrow> ('d,'v stack,'i,'p) vm_core_state) \<Rightarrow> ('d,'v,'i,'p) word_dict \<Rightarrow> ('d,'v,'i,'p) word_dict" where
  "register_word name f dict = (name, f) # dict"

context vm_stack_runtime begin

definition register_return_stack_words :: "('dict,'val,'io,'phys) word_dict \<Rightarrow> ('dict,'val,'io,'phys) word_dict" where
  "register_return_stack_words dict =
      register_word \"R@\" word_peek_return (
      register_word \"R>\" word_from_return (
      register_word \">R\" word_to_return dict))"

definition register_data_stack_words :: "('dict,'val,'io,'phys) word_dict \<Rightarrow> ('dict,'val,'io,'phys) word_dict" where
  "register_data_stack_words dict =
      register_word \"ROLL\" word_roll (
      register_word \"PICK\" word_pick (
      register_word \"DEPTH\" word_depth (
      register_word \"-ROT\" word_minus_rot (
      register_word \"ROT\" word_rot (
      register_word \"OVER\" word_over (
      register_word \"SWAP\" word_swap (
      register_word \"?DUP\" word_qdup (
      register_word \"DUP\" word_dup (
      register_word \"DROP\" word_drop dict)))))))))"

lemma lookup_register_word_same:
  "lookup_word name (register_word name f dict) = Some f"
  unfolding register_word_def by simp

lemma lookup_register_word_other:
  assumes "name \<noteq> name'"
  shows "lookup_word name (register_word name' f dict) = lookup_word name dict"
  using assms unfolding register_word_def by simp

lemma register_return_stack_words_to_r:
  "lookup_word \">R\" (register_return_stack_words dict) = Some word_to_return"
  unfolding register_return_stack_words_def
  by (simp add: register_word_def)

lemma register_return_stack_words_r_from:
  "lookup_word \"R>\" (register_return_stack_words dict) = Some word_from_return"
  unfolding register_return_stack_words_def register_word_def
  by simp

lemma register_return_stack_words_r_peek:
  "lookup_word \"R@\" (register_return_stack_words dict) = Some word_peek_return"
  unfolding register_return_stack_words_def
  by (simp add: register_word_def)

lemma register_return_stack_words_preserve_other:
  assumes name \notin set [\">R\", \"R>\", \"R@\"]
  shows "lookup_word name (register_return_stack_words dict) = lookup_word name dict"
  using assms unfolding register_return_stack_words_def register_word_def by simp

lemma register_data_stack_words_drop:
  "lookup_word \"DROP\" (register_data_stack_words dict) = Some word_drop"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_dup:
  "lookup_word \"DUP\" (register_data_stack_words dict) = Some word_dup"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_qdup:
  "lookup_word \"?DUP\" (register_data_stack_words dict) = Some word_qdup"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_swap:
  "lookup_word \"SWAP\" (register_data_stack_words dict) = Some word_swap"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_over:
  "lookup_word \"OVER\" (register_data_stack_words dict) = Some word_over"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_rot:
  "lookup_word \"ROT\" (register_data_stack_words dict) = Some word_rot"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_minus_rot:
  "lookup_word \"-ROT\" (register_data_stack_words dict) = Some word_minus_rot"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_depth:
  "lookup_word \"DEPTH\" (register_data_stack_words dict) = Some word_depth"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_pick:
  "lookup_word \"PICK\" (register_data_stack_words dict) = Some word_pick"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_roll:
  "lookup_word \"ROLL\" (register_data_stack_words dict) = Some word_roll"
  unfolding register_data_stack_words_def by (simp add: register_word_def)

lemma register_data_stack_words_preserve_other:
  assumes name \notin set [\"DROP\", \"DUP\", \"?DUP\", \"SWAP\", \"OVER\", \"ROT\", \"-ROT\", \"DEPTH\", \"PICK\", \"ROLL\"]
  shows "lookup_word name (register_data_stack_words dict) = lookup_word name dict"
  using assms unfolding register_data_stack_words_def register_word_def by simp

end

end
----

== Verification Notes

=== Proof Method

This theory was verified using **Isabelle/HOL**, a proof assistant based on:

* **Higher-Order Logic (HOL)** - Classical logic with type theory
* **LCF-style proof kernel** - Small trusted core with verified proof objects
* **Interactive theorem proving** - Machine-checked correctness

=== Assurance Level

[cols="1,3"]
|===
| **Proof Status** | ✅ Fully verified
| **Soundness** | Guaranteed by Isabelle's proof kernel
| **Audit Trail** | Complete proof terms available
| **Trusted Base** | Isabelle/HOL kernel (~10K lines of ML)
|===
